/**
 * ProjectLoom Type Definitions
 * 
 * Core types for Workspace, Conversation (Card), Message, AI Provider,
 * and related interfaces. v4 Architecture with card-level branching
 * and multi-parent merge support.
 * 
 * @version 4.0.0
 */

// =============================================================================
// SCHEMA VERSION
// =============================================================================

export const SCHEMA_VERSION = 4;

// =============================================================================
// POSITION & GEOMETRY
// =============================================================================

/**
 * 2D position on the canvas
 */
export interface Position {
  x: number;
  y: number;
}

/**
 * Rectangular bounds
 */
export interface Bounds {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
  width: number;
  height: number;
}

// =============================================================================
// LANGUAGE & TEXT
// =============================================================================

/**
 * ISO 639-1 language codes with common additions
 */
export type LanguageCode = 
  | 'en' | 'ja' | 'zh' | 'ko' | 'ar' | 'he' | 'th' | 'hi'
  | 'es' | 'fr' | 'de' | 'pt' | 'ru' | 'it' | 'nl' | 'pl'
  | 'und' // undefined/unknown
  | string;

/**
 * Text direction
 */
export type TextDirection = 'ltr' | 'rtl';

/**
 * Script types for font mapping
 */
export type ScriptType = 
  | 'latin' 
  | 'japanese' 
  | 'chinese' 
  | 'korean' 
  | 'arabic' 
  | 'hebrew' 
  | 'thai' 
  | 'devanagari'
  | 'cyrillic';

// =============================================================================
// MESSAGE
// =============================================================================

/**
 * Role of the message sender
 */
export type MessageRole = 'user' | 'assistant' | 'system';

/**
 * Metadata associated with a message
 */
export interface MessageMetadata {
  /** AI model that generated the response (for assistant messages) */
  model?: string;
  /** Token count for the message */
  tokens?: number;
  /** Detected language of the message content */
  language?: LanguageCode;
  /** Custom key-value metadata */
  custom?: Record<string, unknown>;
}

/**
 * Snapshot of canvas-level context at send time (optional)
 */
export interface MessageContextSnapshot {
  /** Instructions applied when the message was sent */
  instructions?: string;
  /** Knowledge base file IDs applied when the message was sent */
  knowledgeBaseFileIds?: string[];
}

/**
 * A single message in a conversation
 */
/**
 * An attachment on a message (e.g. image for vision models)
 */
export interface MessageAttachment {
  /** Unique identifier */
  id: string;
  /** MIME type (e.g. image/png, image/jpeg) */
  contentType: string;
  /** Display name */
  name: string;
  /** Base64 data URL or object URL */
  url: string;
}

export interface Message {
  /** Unique identifier */
  id: string;
  /** Who sent the message */
  role: MessageRole;
  /** Message content (may contain markdown) */
  content: string;
  /** When the message was created */
  timestamp: Date;
  /** Optional metadata */
  metadata?: MessageMetadata;
  /** Optional canvas-level context snapshot */
  contextSnapshot?: MessageContextSnapshot;
  /** Optional file/image attachments */
  attachments?: MessageAttachment[];
}

// =============================================================================
// CONVERSATION
// =============================================================================

/**
 * Metadata associated with a conversation
 */
export interface ConversationMetadata {
  /** Display title */
  title: string;
  /** Whether the title was set by the user */
  titleIsManual?: boolean;
  /** Whether the title was auto-generated */
  titleAutoGenerated?: boolean;
  /** When the conversation was created */
  createdAt: Date;
  /** When the conversation was last updated */
  updatedAt: Date;
  /** Number of messages in the conversation */
  messageCount: number;
  /** Tags for categorization */
  tags: string[];
  /** Whether the card is currently expanded */
  isExpanded: boolean;
  /** Detected primary language */
  language?: LanguageCode;
}

// =============================================================================
// CARD-LEVEL BRANCHING (v4)
// =============================================================================

/**
 * Branch point information - where this card branched from
 */
export interface BranchPoint {
  /** Parent card ID that was branched from */
  parentCardId: string;
  /** Message index in parent where branch occurred (0-indexed) */
  messageIndex: number;
}

/**
 * Context inherited from a single parent card
 */
export interface InheritedContextEntry {
  /** How context was inherited */
  mode: InheritanceMode;
  /** Messages inherited from this parent */
  messages: Message[];
  /** When this context was captured */
  timestamp: Date;
  /** Total messages in parent at branch time */
  totalParentMessages: number;
}

/**
 * Merge node metadata for synthesis cards
 */
export interface MergeMetadata {
  /** IDs of source cards being merged */
  sourceCardIds: string[];
  /** Optional synthesis prompt used */
  synthesisPrompt?: string;
  /** When merge was created */
  createdAt: Date;
}

/**
 * Merge node configuration limits
 */
export const MERGE_NODE_CONFIG = {
  /** Maximum number of parent cards for a merge node */
  MAX_PARENTS: 5,
  /** Show warning indicator at this threshold */
  WARNING_THRESHOLD: 3,
  /** Bundle edges visually at this threshold */
  BUNDLE_THRESHOLD: 4,
} as const;

/**
 * A conversation node (card) on the canvas
 * v4: Supports card-level branching and multi-parent merge
 */
export interface Conversation {
  /** Unique identifier */
  id: string;
  /** ID of the workspace this conversation belongs to */
  canvasId: string;
  /** Position on the canvas */
  position: Position;
  /** Messages in this conversation */
  content: Message[];
  /** IDs of connected conversations (reference edges) */
  connections: string[];
  /** Conversation metadata */
  metadata: ConversationMetadata;
  
  // === Card-Level Branching (v4) ===
  
  /** Parent card IDs (supports multiple for merge nodes) */
  parentCardIds: string[];
  /** Branch point info - where this card branched from */
  branchPoint?: BranchPoint;
  /** Context inherited from parent cards */
  inheritedContext: Record<string, InheritedContextEntry>;
  /** Whether this is a merge/synthesis node */
  isMergeNode: boolean;
  /** Merge metadata (only if isMergeNode is true) */
  mergeMetadata?: MergeMetadata;
}

// =============================================================================
// WORKSPACE (formerly Canvas - v4 flat structure)
// =============================================================================

/**
 * Workspace metadata (v4)
 */
export interface WorkspaceMetadata {
  /** Display title for the workspace */
  title: string;
  /** When the workspace was created */
  createdAt: Date;
  /** When the workspace was last updated */
  updatedAt: Date;
  /** Optional color coding */
  color?: string;
  /** Schema version */
  schemaVersion: number;
}

// =============================================================================
// WORKSPACE CONTEXT (Phase 2)
// =============================================================================

/**
 * Knowledge base file metadata stored with a workspace
 */
export interface KnowledgeBaseFileMeta {
  /** Unique identifier */
  id: string;
  /** Original file name */
  name: string;
  /** MIME type */
  type: string;
  /** File size in bytes */
  size: number;
  /** Last modified timestamp */
  lastModified: number;
}

/**
 * Canvas-level instructions and knowledge base
 */
export interface WorkspaceContext {
  /** Global instructions for the workspace */
  instructions: string;
  /** Knowledge base file metadata (contents stored in IndexedDB) */
  knowledgeBaseFiles: KnowledgeBaseFileMeta[];
  /** When the context was last updated */
  updatedAt: Date;
}

/**
 * A workspace containing conversation cards (v4)
 * Workspaces are flat - no parent/child hierarchy
 * Card-level branching happens within a workspace
 */
export interface Workspace {
  /** Unique identifier */
  id: string;
  /** Display title */
  title: string;
  /** Conversation cards on this workspace */
  conversations: Conversation[];
  /** Edge connections between cards */
  edges: EdgeConnection[];
  /** Tags for categorization */
  tags: string[];
  /** Canvas-level instructions and knowledge base */
  context: WorkspaceContext;
  /** Workspace metadata */
  metadata: WorkspaceMetadata;
}

/**
 * @deprecated Use Workspace instead (v4 migration)
 * Canvas is now just an alias for Workspace
 */
export type Canvas = Workspace;

/**
 * Canvas metadata - alias for WorkspaceMetadata
 * @deprecated Use WorkspaceMetadata
 */
export type CanvasMetadata = WorkspaceMetadata;

// =============================================================================
// EDGE CONNECTIONS
// =============================================================================

/**
 * Edge curve type for React Flow rendering
 */
export type EdgeCurveType = 'bezier' | 'straight' | 'step' | 'smoothstep';

/**
 * Edge relationship type for card-level branching (v4)
 * - branch: Parent → child card (amber, solid)
 * - merge: Source → synthesis merge node (emerald, solid)
 * - reference: Non-hierarchical reference link (violet, dashed)
 */
export type EdgeRelationType = 'branch' | 'merge' | 'reference';

/**
 * Edge styling options
 */
export interface EdgeStyle {
  /** Stroke color */
  stroke?: string;
  /** Stroke width in pixels */
  strokeWidth?: number;
  /** Whether the edge is animated */
  animated?: boolean;
}

/**
 * A connection between two conversation nodes
 */
export interface EdgeConnection {
  /** Unique identifier */
  id: string;
  /** Source conversation ID */
  source: string;
  /** Target conversation ID */
  target: string;
  /** Type of edge curve */
  curveType: EdgeCurveType;
  /** Relationship type (v4) */
  relationType: EdgeRelationType;
  /** Whether the edge shows animation */
  animated?: boolean;
  /** Custom styling */
  style?: EdgeStyle;
  /** Optional label */
  label?: string;
}

// =============================================================================
// CONTEXT INHERITANCE (Phase 2)
// =============================================================================

/**
 * A decision recorded in the conversation
 */
export interface Decision {
  id: string;
  description: string;
  madeAt: Date;
  /** Reference to the message where decision was made */
  messageId: string;
}

/**
 * An assumption in the conversation
 */
export interface Assumption {
  id: string;
  description: string;
  createdAt: Date;
  status: 'active' | 'invalidated' | 'confirmed';
}

/**
 * Metadata about the context state
 */
export interface ContextMetadata {
  /** Recorded decisions */
  decisions: Decision[];
  /** Assumptions made */
  assumptions: Assumption[];
  /** User-provided reason for the branch */
  branchReason: string;
  /** Total message count at branch time */
  messageCount: number;
  /** Estimated token count */
  tokenCount?: number;
}

/**
 * Snapshot of context at branch time (Phase 2)
 */
export interface ContextSnapshot {
  /** Complete conversation history */
  messages: Message[];
  /** Context metadata */
  metadata: ContextMetadata;
  /** When the snapshot was created */
  timestamp: Date;
  /** Parent canvas ID */
  parentCanvasId: string;
  /** Source conversation ID */
  sourceConversationId: string;
}

/**
 * How context is inherited
 */
export type InheritanceMode = 'full';

/**
 * Message selection for custom inheritance
 */
export interface MessageSelection {
  includeIds: string[];
  excludeIds: string[];
}

/**
 * Branch metadata for tracking lineage (v4 - card level)
 */
export interface BranchMetadata {
  /** ID of the card this branch was created from */
  parentCardId: string;
  /** Message index where branch occurred */
  messageIndex: number;
  /** Number of messages inherited */
  inheritedMessageCount: number;
  /** Inheritance mode used */
  inheritanceMode: InheritanceMode;
  /** Timestamp when branch was created */
  createdAt: Date;
}

/**
 * Data required to create a branch from a message (v4)
 */
export interface BranchFromMessageData {
  /** ID of the source card to branch from */
  sourceCardId: string;
  /** Message index to branch from (0-indexed) */
  messageIndex: number;
  /** How to inherit context: 'full' only */
  inheritanceMode: InheritanceMode;
  /** Optional reason for the branch */
  branchReason?: string;
  /** Optional target position for the new card */
  targetPosition?: Position;
}

/**
 * Data required to create a merge node (v4)
 */
export interface CreateMergeNodeData {
  /** IDs of source cards to merge */
  sourceCardIds: string[];
  /** Position for the new merge node */
  position: Position;
  /** Optional synthesis prompt */
  synthesisPrompt?: string;
  /** Per-parent inheritance mode (defaults to 'full' if not specified) */
  inheritanceModes?: Record<string, InheritanceMode>;
}

/**
 * @deprecated Use BranchFromMessageData (v4)
 */
export interface BranchData {
  /** ID of the source conversation to branch from */
  sourceConversationId: string;
  /** User-provided reason for the branch */
  branchReason: string;
  /** How to inherit context */
  inheritanceMode: InheritanceMode;
  /** Selected message IDs (for custom mode) */
  customMessageIds?: string[];
}

/**
 * User preferences for branching
 */
export interface BranchingPreferences {
  /** Default inheritance mode */
  defaultInheritanceMode: InheritanceMode;
}

// =============================================================================
// AI PROVIDER (Phase 2)
// =============================================================================

/**
 * Provider identifier
 */
export type ProviderId = 'claude' | 'openai' | 'local' | string;

/**
 * Configuration for an AI provider
 */
export interface ProviderConfig {
  /** API key (if required) */
  apiKey?: string;
  /** Base URL for API calls */
  baseUrl?: string;
  /** Default model to use */
  defaultModel?: string;
  /** Maximum tokens per request */
  maxTokens?: number;
  /** Temperature for responses */
  temperature?: number;
}

/**
 * Context passed to AI provider
 */
export interface AIContext {
  /** Message history */
  messages: Message[];
  /** System prompt */
  systemPrompt?: string;
  /** Additional metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Response from AI provider
 */
export interface AIResponse {
  /** Response content */
  content: string;
  /** Model used */
  model: string;
  /** Token usage */
  tokens: {
    input: number;
    output: number;
  };
  /** Why the response ended */
  finishReason: 'stop' | 'length' | 'error';
}

/**
 * Information about an AI model
 */
export interface ModelInfo {
  /** Model identifier */
  id: string;
  /** Display name */
  name: string;
  /** Maximum context tokens */
  maxTokens: number;
  /** Whether streaming is supported */
  supportsStreaming: boolean;
}

/**
 * AI Provider interface (Phase 2)
 */
export interface AIProvider {
  /** Provider identifier */
  id: ProviderId;
  /** Display name */
  name: string;
  /** Provider configuration */
  config: ProviderConfig;
  /** Send a message and get response */
  sendMessage(content: string, context: AIContext): Promise<AIResponse>;
  /** Stream a message response */
  streamMessage(content: string, context: AIContext): AsyncIterator<AIResponse>;
  /** Check if provider is available */
  isAvailable(): Promise<boolean>;
  /** Get available models */
  getModels(): Promise<ModelInfo[]>;
}

// =============================================================================
// STORAGE (v4)
// =============================================================================

/**
 * User preferences
 */
export interface UserPreferences {
  /** Theme (dark-only in Phase 1) */
  theme: 'dark';
  /** Default inheritance mode */
  defaultInheritanceMode: InheritanceMode;
  /** Whether to show minimap */
  showMinimap: boolean;
  /** Whether to show dev overlay */
  showDevOverlay: boolean;
  /** Branching preferences */
  branching: BranchingPreferences;
}

/**
 * Workspace storage data (v4 - flat workspaces)
 */
export interface WorkspaceStorageData {
  /** Schema version */
  schemaVersion: number;
  /** All workspaces (flat, no hierarchy) */
  workspaces: Workspace[];
  /** Currently active workspace ID */
  activeWorkspaceId: string;
  /** Last updated timestamp */
  lastUpdated: string;
}

/**
 * @deprecated Use WorkspaceStorageData (v4)
 */
export interface CanvasStorageData {
  /** All canvases */
  canvases: Canvas[];
  /** Currently active canvas ID */
  activeCanvasId: string;
  /** User settings */
  settings: {
    theme: 'dark';
    showMinimap: boolean;
    snapToGrid: boolean;
  };
}

/**
 * Complete storage schema (v4)
 */
export interface StorageData {
  /** Schema version */
  schemaVersion: number;
  /** All conversations */
  conversations: Conversation[];
  /** Node positions by conversation ID */
  positions: Record<string, Position>;
  /** Edge connections */
  connections: EdgeConnection[];
  /** Canvas settings */
  settings: {
    theme: 'dark';
    showMinimap: boolean;
    snapToGrid: boolean;
  };
}

// =============================================================================
// UI STATE
// =============================================================================

/**
 * Card state for z-index and styling
 */
export interface CardState {
  isExpanded?: boolean;
  isDragging?: boolean;
  isHovered?: boolean;
  isSelected?: boolean;
}

/**
 * Viewport state
 */
export interface ViewportState {
  x: number;
  y: number;
  zoom: number;
}

// =============================================================================
// REACT FLOW TYPES
// =============================================================================

/**
 * React Flow node data for conversation cards
 * Extends Record<string, unknown> for React Flow compatibility
 */
export interface ConversationNodeData extends Record<string, unknown> {
  conversation: Conversation;
  isExpanded: boolean;
  isSelected: boolean;
}

/**
 * React Flow edge data
 */
export interface ConversationEdgeData {
  connection: EdgeConnection;
}

// =============================================================================
// UTILITY TYPES
// =============================================================================

/**
 * Make all properties optional recursively
 */
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Extract the ID type from an entity
 */
export type EntityId = string;

/**
 * Timestamp as ISO string or Date
 */
export type Timestamp = Date | string;
