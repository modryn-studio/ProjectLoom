'use client';

import React, { useCallback, memo, useEffect, useRef, useState } from 'react';
import { X, GitBranch, Zap, Maximize2, BarChart3 } from 'lucide-react';

import { colors, typography, spacing, effects } from '@/lib/design-tokens';
import { useCanvasStore, selectUsagePanelOpen } from '@/stores/canvas-store';
import { enforceTitleWordLimit } from '@/utils/formatters';
import type { Conversation } from '@/types';

// =============================================================================
// CHAT PANEL HEADER COMPONENT
// =============================================================================

interface ChatPanelHeaderProps {
  conversation: Conversation;
  onClose: () => void;
  onMaximize?: () => void;
}

export const ChatPanelHeader = memo(function ChatPanelHeader({ 
  conversation, 
  onClose,
  onMaximize,
}: ChatPanelHeaderProps) {
  const branchFromMessage = useCanvasStore((s) => s.branchFromMessage);
  const updateConversation = useCanvasStore((s) => s.updateConversation);
  const openChatPanel = useCanvasStore((s) => s.openChatPanel);
  const requestFocusNode = useCanvasStore((s) => s.requestFocusNode);
  const toggleUsagePanel = useCanvasStore((s) => s.toggleUsagePanel);
  const usagePanelOpen = useCanvasStore(selectUsagePanelOpen);
  const [isRenaming, setIsRenaming] = useState(false);
  const [draftTitle, setDraftTitle] = useState(conversation.metadata.title);
  const inputRef = useRef<HTMLInputElement>(null);

  // v4: Detect merge and branch state for visual styling
  const isMergeNode = conversation.isMergeNode;
  const hasParents = conversation.parentCardIds.length > 0;
  const isBranchedCard = hasParents && !isMergeNode;
  const mergeSourceCount = isMergeNode ? conversation.parentCardIds.length : 0;
  const isComplexMerge = mergeSourceCount >= 3; // WARNING_THRESHOLD
  const isAtMaxMerge = mergeSourceCount >= 5; // MAX_PARENTS



  // Handle branch action
  const handleBranch = useCallback(() => {
    // Guard against undefined or empty content array
    const messageCount = Array.isArray(conversation.content) ? conversation.content.length : 0;
    const hasInheritedContext = conversation.parentCardIds.length > 0;
    if (messageCount === 0 && !hasInheritedContext) return;

    const branchIndex = messageCount > 0 ? messageCount - 1 : 0;

    const newConversation = branchFromMessage({
      sourceCardId: conversation.id,
      messageIndex: branchIndex,
      branchReason: 'Branch from chat',
    });
    if (newConversation) {
      openChatPanel(newConversation.id);
      requestFocusNode(newConversation.id);
    }
  }, [conversation.id, conversation.content, conversation.parentCardIds.length, branchFromMessage, openChatPanel, requestFocusNode]);

  // Reset draft title when conversation changes - intentional reset behavior
  useEffect(() => {
    /* eslint-disable react-hooks/set-state-in-effect */
    setDraftTitle(conversation.metadata.title);
    setIsRenaming(false);
    /* eslint-enable react-hooks/set-state-in-effect */
  }, [conversation.id, conversation.metadata.title]);

  useEffect(() => {
    if (isRenaming) {
      requestAnimationFrame(() => inputRef.current?.focus());
    }
  }, [isRenaming]);

  const handleStartRename = useCallback(() => {
    setDraftTitle(conversation.metadata.title);
    setIsRenaming(true);
  }, [conversation.metadata.title]);

  const handleFinishRename = useCallback(() => {
    const trimmed = draftTitle.trim();
    const limitedTitle = enforceTitleWordLimit(trimmed, 5);
    if (!limitedTitle) {
      setDraftTitle(conversation.metadata.title);
      setIsRenaming(false);
      return;
    }

    if (limitedTitle !== conversation.metadata.title) {
      updateConversation(conversation.id, {
        metadata: {
          ...conversation.metadata,
          title: limitedTitle,
          titleIsManual: true,
          titleAutoGenerated: false,
          updatedAt: new Date(),
        },
      });
    }

    if (limitedTitle !== trimmed) {
      setDraftTitle(limitedTitle);
    }
    setIsRenaming(false);
  }, [conversation.id, conversation.metadata, draftTitle, updateConversation]);

  const handleCancelRename = useCallback(() => {
    setDraftTitle(conversation.metadata.title);
    setIsRenaming(false);
  }, [conversation.metadata.title]);

  return (
    <div style={headerStyles.container}>
      <div style={headerStyles.titleRow}>
        {/* Left side: Title and indicators */}
        <div style={headerStyles.titleSection}>
          {/* Merge indicator icon */}
          {isMergeNode && (
            <span
              style={headerStyles.indicator}
              title={`Merged from ${mergeSourceCount} cards`}
            >
              <Zap 
                size={16} 
                color={isAtMaxMerge 
                  ? colors.semantic.error 
                  : isComplexMerge 
                    ? colors.semantic.warning 
                    : colors.semantic.success
                } 
              />
            </span>
          )}
          
          {/* Branch indicator icon */}
          {isBranchedCard && (
            <span style={headerStyles.indicator} title="Branched card">
              <GitBranch size={16} color={colors.accent.emphasis} />
            </span>
          )}

          {isRenaming ? (
            <input
              ref={inputRef}
              value={draftTitle}
              onChange={(e) => setDraftTitle(e.target.value)}
              onBlur={handleFinishRename}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  handleFinishRename();
                } else if (e.key === 'Escape') {
                  handleCancelRename();
                }
              }}
              style={headerStyles.titleInput}
              aria-label="Rename conversation"
            />
          ) : (
            <h2 style={headerStyles.title} onDoubleClick={handleStartRename}>
              {conversation.metadata.title}
            </h2>
          )}
        </div>

        {/* Right side: Actions */}
        <div style={headerStyles.actions}>
          {/* Branch button */}
          <button
            onClick={handleBranch}
            style={headerStyles.actionButton}
            title="Branch from this conversation (Ctrl+B)"
            aria-label="Branch from this conversation"
          >
            <GitBranch size={16} />
          </button>

          {/* Usage button */}
          <button
            onClick={toggleUsagePanel}
            style={{
              ...headerStyles.actionButton,
              backgroundColor: usagePanelOpen ? colors.accent.muted : 'transparent',
              borderColor: usagePanelOpen ? colors.accent.primary : 'var(--border-primary)',
              color: usagePanelOpen ? colors.accent.primary : colors.fg.secondary,
            }}
            title="Usage"
            aria-label="Toggle usage panel"
          >
            <BarChart3 size={16} />
          </button>

          {/* Maximize button */}
          {onMaximize && (
            <button
              onClick={onMaximize}
              style={headerStyles.actionButton}
              title="Maximize chat (fullscreen)"
              aria-label="Maximize chat"
            >
              <Maximize2 size={16} />
            </button>
          )}

          {/* Close button */}
          <button
            onClick={onClose}
            style={headerStyles.closeButton}
            title="Close panel (Escape)"
            aria-label="Close chat panel"
          >
            <X size={16} />
          </button>
        </div>
      </div>
    </div>
  );
});

// =============================================================================
// STYLES
// =============================================================================

const headerStyles: Record<string, React.CSSProperties> = {
  container: {
    display: 'flex',
    flexDirection: 'column',
    borderBottom: '1px solid var(--border-secondary)',
    backgroundColor: colors.bg.secondary,
    flexShrink: 0,
    gap: spacing[1],
  },

  titleRow: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: `${spacing[2]} ${spacing[3]}`,
    gap: spacing[2],
  },

  titleSection: {
    display: 'flex',
    alignItems: 'center',
    gap: spacing[2],
    flex: 1,
    minWidth: 0, // Allow text truncation
  },

  indicator: {
    display: 'flex',
    alignItems: 'center',
    flexShrink: 0,
  },

  title: {
    fontSize: typography.sizes.sm,
    fontWeight: typography.weights.semibold,
    color: colors.fg.primary,
    fontFamily: typography.fonts.heading,
    margin: 0,
    lineHeight: typography.lineHeights.tight,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
  },

  titleInput: {
    minWidth: 0,
    fontSize: typography.sizes.sm,
    fontWeight: typography.weights.semibold,
    fontFamily: typography.fonts.heading,
    color: colors.fg.primary,
    backgroundColor: colors.bg.inset,
    border: `1px solid ${colors.accent.primary}`,
    borderRadius: effects.border.radius.default,
    padding: `2px ${spacing[1]}`,
    outline: 'none',
  },

  actions: {
    display: 'flex',
    alignItems: 'center',
    gap: spacing[1],
    flexShrink: 0,
  },

  actionButton: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: spacing[1],
    backgroundColor: 'transparent',
    border: '1px solid var(--border-primary)',
    borderRadius: effects.border.radius.default,
    color: colors.fg.secondary,
    cursor: 'pointer',
    transition: 'all 0.15s ease',
  },

  closeButton: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: spacing[1],
    backgroundColor: 'transparent',
    border: '1px solid var(--border-primary)',
    borderRadius: effects.border.radius.default,
    color: colors.fg.tertiary,
    cursor: 'pointer',
    transition: 'all 0.15s ease',
  },
};

export default ChatPanelHeader;
